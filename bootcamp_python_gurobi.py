# -*- coding: utf-8 -*-
"""Bootcamp Python-Gurobi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1firy3njLTb0x6IzT9ZpEw4K-YwGvJuKv

##Problemas de Localización usando python-gurobi

Para esta práctica utilizaremos datos reales de la Región Metropolitana que pueden descargar desde el siguiente link https://docs.google.com/spreadsheets/d/1pZynsI5vH3dNVyCxAt81PZO_f4aPvayp/edit?usp=sharing&ouid=100828000732918673128&rtpof=true&sd=true

Si visualizamos el archivo podemos notar que no están todos los datos necesarios para los modelos vistos, falta las distancias, coordenadas, costos, etc.

Lo primero que se realizará es instalar el paquete geopy el cual nos ayudará a encontrar direcciones, coordenadas, distancias, entre otros datos espaciales (Más información en: https://geopy.readthedocs.io/en/stable/).
"""

!pip install geopy #Instalación paquete geopy

"""Al usar google colab tenemos la opción de utilizar archivos que están almacenados en google drive."""

from google.colab import drive #Uso de google drive para extraer base de datos (excel)
drive.mount('/content/drive')

"""Importamos de la libreria geopy el modulo de Nominatim. Esto nos permitirá utilizar datos directamente de OpenStreetMaps, el cual no utiliza licencia y es totalmente gratuita (Más información en: https://nominatim.org/)"""

from geopy.geocoders import Nominatim
geolocator = Nominatim(timeout=10, user_agent = "dlab.berkeley.edu-workshop") #activa geolocalización de Nominatim

import pandas as pd
datos = pd.read_excel("/content/drive/MyDrive/Bootcamp/Datos.xlsx") #importar archivo de direcciones (puntos de demanda)
#data_datos = datos.to_dict("list") #Tener acceso por columna como una lista
print(datos)
#print(data_datos)

# Crear listas para almacenar las coordenadas
latitudes = []
longitudes = []
# Iterar sobre las direcciones y obtener las coordenadas
for address in datos['Shpr_Addr']:
    location = geolocator.geocode(address)
    if location is not None:
        latitudes.append(location.latitude)
        longitudes.append(location.longitude)
    else:
        latitudes.append("no encontrado")
        longitudes.append("no encontrado")

# Agregar las coordenadas al DataFrame
datos['Latitud'] = latitudes
datos['Longitud'] = longitudes

# Guardar el DataFrame actualizado en el mismo archivo Excel
datos.to_excel("/content/drive/MyDrive/Bootcamp/Datos.xlsx", index=False)

"""# Visualización de Datos

Visualizar los datos cuando tenemos información geografica nos ayuda a entender mejor el problema.
Para esto utilizaremos mapas dinámicos con la libreria folium y branca (Más información en: https://pypi.org/project/folium/ https://pypi.org/project/branca/)

Para un mejor uso posterior en los mapas guardaremos la posición en un diccionario, además esto le dara una clave a cada punto de más facil lectura que la que tiene actualmente la base de datos.
"""

import folium
import branca
posicion = {}
for i in range(len(datos['HWB No'])):
    posicion[i]= (datos['Latitud'][i],datos['Longitud'][i])
print(posicion)

"""###**Mapas de puntos**
Folium y branca en conjunto nos puede brindar algunos mapas dinamicos con distintas caracteristicas.
Podemos cambiar las caracteristicas de estos mapas a nuestro gusto personal.
"""

mi_mapa = folium.Map(location=(-33.4, -70.6), zoom_start=9, maptype="satellite") #Crea mapa
marcador = {}; arrow={}

html1 = lambda j:     "<p> Punto: " + str(datos['HWB No'][j])+\
                          "<p> Dirección: " + str(datos['Shpr_Addr'][j]) + \
                          "<p> Tipo: " + str(datos['Description'][j]) #popup1

for j in range(len(datos['HWB No'])):
    marcador[j] = folium.Marker(location = posicion[j],
                                            popup = folium.Popup(branca.element.IFrame(html=html1(j), width=250, height=150), max_width=250),
                                     icon = folium.Icon(color="red")).add_to(mi_mapa)

name = ("mapa 1.html")
mi_mapa.save(name) #guardar mapa en un html
mi_mapa

"""###**Mapas de calor**
Para una visualización más sencilla se realiza un mapa de calor de la demanda. Se mapea la demanda y podemos ver qué áreas tienen una mayor demanda frente a otras
"""

from folium.plugins import HeatMap
# extrayendo los valores de longitud y latitud a listas separadas
longs = datos['Longitud']
lats = datos['Latitud']

# crear un objeto mapa base usando Map()
mapObj = folium.Map(location=(-33.4, -70.6), zoom_start = 10)
marcador = {}; arrow={}

html3 = lambda j: "<p> Punto: " + str(datos['HWB No'][j])+\
                          "<p> Dirección: " + str(datos['Shpr_Addr'][j])
# crear capa de mapa de calor
for j in range(len(datos['HWB No'])):
  marcador[j] = folium.Marker(location = posicion[j],
                              popup = folium.Popup(branca.element.IFrame(html=html3(j), width=250, height=150), max_width=250),
                              icon = folium.Icon(color="red")).add_to(mapObj)

heatmap = HeatMap( list(zip(lats, longs, datos['Weight'])),
                   min_opacity=0.2,
                   radius=50, blur=50,
                   max_zoom=1)
# añadir capa de mapa de calor al mapa base
heatmap.add_to(mapObj)
name = ("mapa calor.html")
mapObj.save(name)
mapObj

"""##Gurobi en colab
Podemos usar una licencia propia de gurobi en colab solicitando una licencia tipo WLS en https://portal.gurobi.com/iam/licenses/list, se solicita la licencia, se descarga, podemos abrir el archivo como un txt y copiamos la información.
"""

!pip install gurobipy  # install gurobipy, if not already installed
import gurobipy as gp

params = {
"WLSACCESSID": '****',
"WLSSECRET": '****',
"LICENSEID": '****',
}
env = gp.Env(params=params)

"""#Modelo de cobertura
####Conjuntos y parámetros
$N$: Conjunto de nodos (puntos)\
$a_{ij}$: Parámetro de cobertura\
$f_i$: Costo de localizar una instalación en el nodo j\
$M$: Conjunto de posibles localizaciones
#### Variables de decisión
$x_j$: 1, si se localiza una instalación en j.0, e.o.c.
#### Modelo
\begin{equation}
Mínz=\sum_{j\in M}f_j x_j
\end{equation}
s.a.\
\begin{equation}
\sum_{j\in M}a_{ij}x_i \geq 1, \forall i \in N
\end{equation}
\begin{equation}
x_j \in \{0,1\}, \forall j \in M
\end{equation}

Nos faltan parametros para continuar. El parámetro de cobertura y los costos fijos. \
Por simplicidad tomaremos el conjunto M = N para este caso. \
Los costos fijos los tomaremos como aleatorios entre 100 y 200.

La distancia la podemos calcular con geopy, a diferencia de la distancia euclidiana, geopy recopila información geografica del mapa OpenStreetMap lo que nos permite tener la información de la distancia entre cada punto en km reales recorridos entre dos puntos.
Geopy utiliza la ruta más corta para calcular la distancia.
"""

#calculo de matriz de distancia en km
from geopy.distance import geodesic

dist={}
for i in range(len(datos['HWB No'])):
  for j in range(len(datos['HWB No'])):
    dist[i,j]=geodesic(posicion[i],posicion[j]).km

a = {}
for i in range(len(datos['HWB No'])):
  for j in range(len(datos['HWB No'])):
      if dist[i,j] <= 3:
        a[i,j] = 1
      else:
        a[i,j]=0

print(dist[1,4],a[1,4])

import random
f = {}
for i in range(len(datos['HWB No'])):
  f[i] = random.randint(100, 200)

print(f)

import time
from gurobipy import *
def SCP(a,f):

    N = range(len(datos['HWB No']))

    m=gp. Model('SCP', env=env)
    m.Params.OutputFlag = 1
    formIT = time.time() #Tiempo inicial de formulación

    ########### Variables ############################
    x = m.addVars(N, vtype=GRB.BINARY)

    ########### Función objetivo ####################
    m.setObjective(quicksum(f[j]*x[j] for j in N), sense= GRB.MINIMIZE)


    ############Restricciones #########################
    m.addConstrs(quicksum(a[i,j]*x[j] for j in N)>=1 for i in N)

    formET = time.time() #Tiempo final de formulación
    formTT = round(formET - formIT, 2)

    m.update()
    resIT = time.time()
    m.optimize()
    resET = time.time()
    resTT = round(resET - resIT, 2)

    print("\n-------------------------------")
    print("El tiempo total  fue de %f segundos" %( formTT))
    X = {}
    for j in N:
      X[j] = x[j].X
    print(X)
    return m.objVal, X
sol, X = SCP(a,f)
print(sol)

"""#Mapa de solución

"""

mi_mapa = folium.Map(location=(-33.4, -70.6), zoom_start=9, maptype="satellite") #Crea mapa
marcador = {}; arrow={}

html1 = lambda j:     "<p> Punto: " + str(datos['HWB No'][j])+\
                          "<p> Dirección: " + str(datos['Shpr_Addr'][j]) + \
                          "<p> Tipo: " + str(datos['Description'][j]) #popup1

for j in range(len(datos['HWB No'])):
   if X[j] == 1:
      marcador[j] = folium.Marker(location = posicion[j],
                                            popup = folium.Popup(branca.element.IFrame(html=html1(j), width=250, height=150), max_width=250),
                                     icon = folium.Icon(color="red")).add_to(mi_mapa)
   else:
    marcador[j] = folium.Marker(location = posicion[j],
                                            popup = folium.Popup(branca.element.IFrame(html=html1(j), width=250, height=150), max_width=250),
                                     icon = folium.Icon(color="blue")).add_to(mi_mapa)
name = ("mapa 2.html")
mi_mapa.save(name) #guardar mapa en un html
mi_mapa

"""###**Problema de la p-mediana**

####Conjuntos y parámetros
$N$: Conjunto de nodos (puntos)\
$h_{i}$: Demanda en el nodo\
$d_ij$: distancia entre nodos\
$p$: Cantidad de instalaciones a localizar
#### Variables de decisión
$x_j$: 1, si se localiza una instalación en j.0, e.o.c.
$y_{ij}: 1, Si se asigna la demanda del nodo i a la instalación localizada en el sitio candidato j. 0, e.o.c.
#### Modelo
\begin{equation}
Mínz=\sum_{j\in N}\sum_{i\in N}h_{i}d_{ij}y_{ij}
\end{equation}
s.a.\
\begin{equation}
\sum_{j\in N}y_{ij} = 1, \forall i \in N
\end{equation}
\begin{equation}
\sum_{j\in N}x_j = p
\end{equation}
\begin{equation}
y_{ij} <= x_{j} \forall i\in N, j\in N
\end{equation}

\begin{equation}
x_{j}, y_{ij} \in \{0,1\} \forall i\in N, j\in N
\end{equation}
"""

h = {}
for i in range(len(datos['HWB No'])):
  h[i] = datos["Weight"][i]
print(h)

N = range(len(datos['HWB No']))

m=gp. Model('pmed', env=env)
m.Params.OutputFlag = 1
formIT = time.time() #Tiempo inicial de formulación

########### Variables ############################
x = m.addVars(N, vtype=GRB.BINARY)
y = m.addVars(N,N, vtype = GRB.BINARY)
########### Función objetivo ####################
m.setObjective(quicksum(h[i]*dist[i,j]*y[i,j] for i in N for j in N), sense= GRB.MINIMIZE)


############Restricciones #########################
m.addConstrs(quicksum(y[i,j] for j in N)==1 for i in N)
m.addConstr(quicksum(x[j] for j in N)==10)
m.addConstrs(y[i,j]<= x[j] for i in N for j in N)

formET = time.time() #Tiempo final de formulación
formTT = round(formET - formIT, 2)
m.update()
resIT = time.time()
m.optimize()
resET = time.time()
resTT = round(resET - resIT, 2)

print("\n-------------------------------")
print("El tiempo total  fue de %f segundos" %( formTT))
X = {}
Y={}
for i in N:
    X[i] = x[i].X
    for j in N:
      Y[i,j] = y[i,j].X

solucion = m.objVal
print(solucion)

"""Conocer el estado del modelo, donde puede indicar hasta 15 estados distintos, que puede ver en el siguiente enlace  

https://www.gurobi.com/documentation/9.1/refman/optimization_status_codes.html#sec:StatusCodes.  
"""

print(m.status)

mi_mapa = folium.Map(location=(-33.4, -70.6), zoom_start=9, maptype="satellite") #Crea mapa
marcador = {}; arrow={}

html1 = lambda j:     "<p> Punto: " + str(datos['HWB No'][j])+\
                          "<p> Dirección: " + str(datos['Shpr_Addr'][j]) + \
                          "<p> Tipo: " + str(datos['Description'][j]) #popup1

for j in range(len(datos['HWB No'])):
   if X[j] == 1:
      marcador[j] = folium.Marker(location = posicion[j],
                                            popup = folium.Popup(branca.element.IFrame(html=html1(j), width=250, height=150), max_width=250),
                                     icon = folium.Icon(color="red")).add_to(mi_mapa)
   else:
    marcador[j] = folium.Marker(location = posicion[j],
                                            popup = folium.Popup(branca.element.IFrame(html=html1(j), width=250, height=150), max_width=250),
                                     icon = folium.Icon(color="blue")).add_to(mi_mapa)
   for i in range(len(datos['HWB No'])):
          if Y[i,j] == 1:
            arrow[i,j] = folium.PolyLine(locations=[posicion[i], posicion[j]], weight=1, color='red').add_to(mi_mapa)
name = ("mapa 2.html")
mi_mapa.save(name) #guardar mapa en un html
mi_mapa